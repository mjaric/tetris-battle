# CI/CD — GitHub Actions Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Set up two GitHub Actions workflows — a manual PR guard (lint/test) and a tag-triggered
release pipeline that builds and pushes a single Docker image (React SPA + Elixir backend).

**Architecture:** React is built at Docker image build time and its static output is copied into
the Elixir OTP release under `priv/static/`. Phoenix serves these files via `Plug.Static`. A
catch-all router route serves `index.html` for client-side routes. Nginx is deployment-only
(TLS termination, reverse proxy) and is out of scope for this plan.

**Tech Stack:** GitHub Actions, Docker (multi-stage), hexpm/elixir, debian-slim, GHCR (ghcr.io),
Elixir/Phoenix, Credo, mix format, Oxlint, Prettier, Vite/TypeScript

---

## Task 1: Configure mix format line length

**Files:**
- Modify: `server/.formatter.exs`

**Step 1: Update `.formatter.exs` to enforce 120-char lines**

Replace the entire file with:

```elixir
# Used by "mix format"
[
  inputs: ["{mix,.formatter}.exs", "{config,lib,test}/**/*.{ex,exs}"],
  line_length: 120
]
```

**Step 2: Reformat existing code**

```bash
cd server && mix format
```

Review the diff with `git diff`. If large changes appear, they are formatting-only — safe to commit.

**Step 3: Verify check mode works**

```bash
cd server && mix format --check-formatted
```

Expected: exits 0 with no output.

**Step 4: Commit**

```bash
git add server/.formatter.exs server/
git commit -m "chore: enforce 120-char line length in mix format"
```

---

## Task 2: Add Credo and configure function/line limits

**Files:**
- Modify: `server/mix.exs`
- Create: `server/.credo.exs`

**Step 1: Add Credo to deps in `server/mix.exs`**

Find the `defp deps do` block. Add after the last existing dep (before the closing `]`):

```elixir
      {:credo, "~> 1.7", only: [:dev, :test], runtime: false}
```

**Step 2: Fetch the new dep**

```bash
cd server && mix deps.get
```

**Step 3: Create `server/.credo.exs`**

```elixir
%{
  configs: [
    %{
      name: "default",
      files: %{
        included: ["lib/", "test/"],
        excluded: []
      },
      strict: true,
      checks: %{
        extra: [
          {Credo.Check.Readability.MaxLineLength, max_length: 120},
          {Credo.Check.Design.FunctionLength, max_function_length: 100}
        ]
      }
    }
  ]
}
```

**Step 4: Run Credo and fix any violations**

```bash
cd server && mix credo --strict
```

Credo will report issues with file paths and line numbers. Fix each one — common issues:
- Long lines: break them with continuation or restructure expressions
- Long functions: extract private helpers

Repeat until `mix credo --strict` exits 0.

**Step 5: Commit**

```bash
git add server/mix.exs server/mix.lock server/.credo.exs server/lib/
git commit -m "chore: add Credo with 120-char line and 100-line function limits"
```

---

## Task 3: Make CORS configurable via environment variable

**Files:**
- Create: `server/lib/tetris_web/plugs/cors_plug.ex`
- Modify: `server/lib/tetris_web/endpoint.ex`
- Modify: `server/config/runtime.exs`

**Context:** The current endpoint.ex has `plug(Corsica, origins: ["http://localhost:3000"], ...)`.
Plug options are evaluated at compile time, so they cannot read runtime env vars directly.
We wrap Corsica in a custom plug that reads application env at request time (set by runtime.exs
before the app starts).

**Step 1: Create `server/lib/tetris_web/plugs/cors_plug.ex`**

```elixir
defmodule TetrisWeb.CorsPlug do
  @moduledoc "Reads CORS origins from application env at request time for runtime configurability."

  @behaviour Plug

  @impl Plug
  def init(opts), do: opts

  @impl Plug
  def call(conn, _opts) do
    origins = Application.get_env(:tetris, :cors_origins, ["http://localhost:3000"])

    conn
    |> Corsica.call(Corsica.init(origins: origins, allow_headers: :all, allow_methods: :all))
  end
end
```

**Step 2: Update `server/config/runtime.exs`**

Add the CORS and PHX_HOST config inside the `if config_env() == :prod do` block, after the
existing `SECRET_KEY_BASE` lines:

```elixir
  host = System.get_env("PHX_HOST") || raise "environment variable PHX_HOST is missing."

  config :tetris, TetrisWeb.Endpoint,
    http: [ip: {0, 0, 0, 0}, port: String.to_integer(System.get_env("PORT") || "4000")],
    secret_key_base: secret_key_base,
    url: [host: host, port: 443, scheme: "https"]

  cors_origins =
    case System.get_env("CORS_ORIGINS") do
      nil -> ["http://localhost:3000"]
      raw -> String.split(raw, ",", trim: true)
    end

  config :tetris, cors_origins: cors_origins
```

Replace the existing `config :tetris, TetrisWeb.Endpoint` line (which only sets `http` and
`secret_key_base`) with the block above. The full `runtime.exs` should look like:

```elixir
import Config

if config_env() == :prod do
  secret_key_base =
    System.get_env("SECRET_KEY_BASE") ||
      raise """
      environment variable SECRET_KEY_BASE is missing.
      """

  host = System.get_env("PHX_HOST") || raise "environment variable PHX_HOST is missing."

  config :tetris, TetrisWeb.Endpoint,
    http: [ip: {0, 0, 0, 0}, port: String.to_integer(System.get_env("PORT") || "4000")],
    secret_key_base: secret_key_base,
    url: [host: host, port: 443, scheme: "https"]

  cors_origins =
    case System.get_env("CORS_ORIGINS") do
      nil -> ["http://localhost:3000"]
      raw -> String.split(raw, ",", trim: true)
    end

  config :tetris, cors_origins: cors_origins
end
```

**Step 3: Update `server/lib/tetris_web/endpoint.ex`**

Replace the existing `plug(Corsica, ...)` block with the new plug:

```elixir
  plug TetrisWeb.CorsPlug
```

The endpoint should now look like:

```elixir
defmodule TetrisWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :tetris

  socket("/socket", TetrisWeb.UserSocket,
    websocket: true,
    longpoll: false
  )

  plug(Plug.RequestId)
  plug(Plug.Telemetry, event_prefix: [:phoenix, :endpoint])

  if Code.ensure_loaded?(Tidewave) do
    plug(Tidewave)
  end

  plug TetrisWeb.CorsPlug

  plug(Plug.Parsers,
    parsers: [:urlencoded, :multipart, :json],
    pass: ["*/*"],
    json_decoder: Phoenix.json_library()
  )

  plug(Plug.MethodOverride)
  plug(Plug.Head)
  plug(TetrisWeb.Router)
end
```

**Step 4: Verify it compiles**

```bash
cd server && mix compile
```

Expected: no errors or warnings.

**Step 5: Commit**

```bash
git add server/lib/tetris_web/plugs/cors_plug.ex \
        server/lib/tetris_web/endpoint.ex \
        server/config/runtime.exs
git commit -m "feat: make CORS origins configurable via CORS_ORIGINS env var"
```

---

## Task 4: Add static file serving and SPA catch-all route

**Files:**
- Modify: `server/lib/tetris_web/endpoint.ex`
- Modify: `server/lib/tetris_web/router.ex`
- Create: `server/lib/tetris_web/controllers/page_controller.ex`
- Create: `server/priv/static/.gitkeep`

**Context:** Phoenix serves files from `priv/static/` via `Plug.Static`. The Docker build copies
the React `dist/` output there. For client-side routing (React Router), any URL not matched by an
API route must serve `index.html` — that is the catch-all route.

**Step 1: Create `server/priv/static/.gitkeep`**

```bash
mkdir -p server/priv/static && touch server/priv/static/.gitkeep
```

**Step 2: Add `Plug.Static` to `server/lib/tetris_web/endpoint.ex`**

Add the following plug BEFORE the `plug(Plug.Parsers, ...)` line (static files should be served
before request parsing runs):

```elixir
  plug Plug.Static,
    at: "/",
    from: {:tetris, "priv/static"},
    gzip: true
```

**Step 3: Create `server/lib/tetris_web/controllers/page_controller.ex`**

```elixir
defmodule TetrisWeb.PageController do
  use Phoenix.Controller, formats: [:html]

  def index(conn, _params) do
    path = Application.app_dir(:tetris, "priv/static/index.html")

    conn
    |> put_resp_content_type("text/html")
    |> send_file(200, path)
  end
end
```

**Step 4: Add the SPA catch-all to `server/lib/tetris_web/router.ex`**

Add a new scope AFTER the existing `/api` scope. The catch-all must be last:

```elixir
defmodule TetrisWeb.Router do
  use Phoenix.Router

  pipeline :api do
    plug :accepts, ["json"]
  end

  scope "/api", TetrisWeb do
    pipe_through :api
  end

  scope "/", TetrisWeb do
    get "/*path", PageController, :index
  end
end
```

**Step 5: Verify it compiles**

```bash
cd server && mix compile
```

Expected: no errors or warnings.

**Step 6: Quick smoke test in dev**

```bash
cd server && mix phx.server
```

Open `http://localhost:4000` in a browser. Without the React build in `priv/static/`, you will
get a file-not-found error from `send_file` — this is expected in dev. The important thing is
the server starts and the route is registered. Stop the server with Ctrl+C.

**Step 7: Commit**

```bash
git add server/lib/tetris_web/endpoint.ex \
        server/lib/tetris_web/router.ex \
        server/lib/tetris_web/controllers/page_controller.ex \
        server/priv/static/.gitkeep
git commit -m "feat: serve React SPA static files from Phoenix with catch-all route"
```

---

## Task 5: Replace ESLint with Oxlint and add Prettier

**Files:**
- Modify: `client/package.json`
- Delete: `client/eslint.config.js`
- Create: `client/.prettierrc`
- Create: `client/oxlint.json`
- Create: `client/.prettierignore`

**Context:** The project currently uses ESLint with typescript-eslint. We are replacing the entire
ESLint setup with Oxlint (faster, Rust-based) and adding Prettier for formatting enforcement.
Oxlint supports React hooks rules natively.

**Step 1: Delete `client/eslint.config.js`**

```bash
trash client/eslint.config.js
```

(Use `trash` not `rm` to keep it recoverable.)

**Step 2: Create `client/.prettierrc`**

```json
{
  "printWidth": 120,
  "tabWidth": 2,
  "semi": true,
  "singleQuote": true,
  "trailingComma": "es5"
}
```

**Step 3: Create `client/.prettierignore`**

```
dist/
node_modules/
```

**Step 4: Create `client/oxlint.json`**

```json
{
  "plugins": ["react", "react-hooks", "typescript"],
  "rules": {
    "max-lines-per-function": ["error", { "max": 100, "skipComments": true, "skipBlankLines": true }],
    "no-unused-vars": "error",
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

**Step 5: Update `client/package.json` scripts and devDependencies**

Remove these devDependencies (they are ESLint-related):
- `@eslint/js`
- `eslint`
- `eslint-plugin-react-hooks`
- `eslint-plugin-react-refresh`
- `globals`
- `typescript-eslint`

Add these devDependencies (check current stable versions on npmjs.com before pinning):
- `oxlint`
- `prettier`

Update the `scripts` section:

```json
"scripts": {
  "dev": "vite",
  "build": "tsc -b && vite build",
  "format": "prettier --write \"src/**/*.{ts,tsx,js,jsx,css}\"",
  "format:check": "prettier --check \"src/**/*.{ts,tsx,js,jsx,css}\"",
  "lint": "oxlint src/",
  "preview": "vite preview"
}
```

**Step 6: Install new deps and remove old ones**

```bash
cd client && npm install
```

**Step 7: Run format and auto-fix**

```bash
cd client && npm run format
```

This formats all source files. Review the diff with `git diff client/src/`.

**Step 8: Run lint and fix violations**

```bash
cd client && npm run lint
```

Fix any `max-lines-per-function` violations by extracting helper components or functions.
Fix any `no-unused-vars` violations by removing unused identifiers.

Repeat until `npm run lint` exits 0.

**Step 9: Verify TypeScript and build still work**

```bash
cd client && npm run build
```

Expected: builds successfully, output in `client/dist/`.

**Step 10: Commit**

```bash
git add client/
git commit -m "chore: replace ESLint with Oxlint and add Prettier (120-char lines, 100-line functions)"
```

---

## Task 6: Create the Dockerfile

**Files:**
- Create: `Dockerfile` (in repo root)

**Context:** Three-stage build. Stage 1 builds the React SPA. Stage 2 copies the SPA output
into the Elixir project's `priv/static/`, then builds an OTP release. Stage 3 is the minimal
runtime image.

The Vite build output goes to `client/dist/`. The Dockerfile context is the repo root.

**Step 1: Create `Dockerfile` in the repo root**

```dockerfile
# ─── Stage 1: Build React SPA ───────────────────────────────────────────────
FROM node:22-slim AS client-builder

WORKDIR /client

COPY client/package*.json ./
RUN npm ci

COPY client/ ./
RUN npm run build

# ─── Stage 2: Build Elixir OTP release ──────────────────────────────────────
FROM hexpm/elixir:1.18.1-erlang-27.2-debian-bookworm-20250113-slim AS server-builder

WORKDIR /app

RUN mix local.hex --force && mix local.rebar --force

# Fetch deps first (cached layer if mix.lock unchanged)
COPY server/mix.exs server/mix.lock ./
RUN MIX_ENV=prod mix deps.get --only prod && MIX_ENV=prod mix deps.compile

# Copy server source and inject the React build
COPY server/ ./
COPY --from=client-builder /client/dist ./priv/static

RUN MIX_ENV=prod mix release

# ─── Stage 3: Minimal runtime ────────────────────────────────────────────────
FROM debian:bookworm-slim AS runtime

RUN apt-get update && \
    apt-get install -y --no-install-recommends \
      libstdc++6 \
      openssl \
      libncurses5 && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY --from=server-builder /app/_build/prod/rel/tetris ./

ENV PHX_HOST=localhost
ENV PORT=4000
ENV MIX_ENV=prod

EXPOSE 4000

CMD ["bin/tetris", "start"]
```

**Step 2: Test the build locally**

You need Docker installed. Run from the repo root:

```bash
docker build -t tetris:local .
```

Expected: build completes successfully with a final image. If deps fail to compile, check that
`MIX_ENV=prod` is set before `mix deps.get`.

**Step 3: Test the image runs**

```bash
docker run --rm \
  -e SECRET_KEY_BASE=$(cd server && mix phx.gen.secret) \
  -e PHX_HOST=localhost \
  -p 4000:4000 \
  tetris:local
```

Open `http://localhost:4000` — you should see the React app. Stop with Ctrl+C.

**Step 4: Commit**

```bash
git add Dockerfile
git commit -m "feat: add multi-stage Dockerfile (React SPA + Elixir OTP release)"
```

---

## Task 7: Create the PR Guard workflow

**Files:**
- Create: `.github/workflows/ci.yml`

**Context:** Manual dispatch only (`workflow_dispatch`). Detects changed folders by diffing
against `origin/main`. Runs client and server checks in parallel, conditioned on what changed.
Branch protection rules (configured separately in GitHub UI) require these jobs to pass before
merging.

**Step 1: Create `.github/workflows/ci.yml`**

```yaml
name: CI

on:
  workflow_dispatch:

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      client_changed: ${{ steps.diff.outputs.client_changed }}
      server_changed: ${{ steps.diff.outputs.server_changed }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed folders
        id: diff
        run: |
          git fetch origin main
          CHANGED=$(git diff --name-only origin/main...HEAD)
          echo "Changed files:"
          echo "$CHANGED"
          if echo "$CHANGED" | grep -q '^client/'; then
            echo "client_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "client_changed=false" >> "$GITHUB_OUTPUT"
          fi
          if echo "$CHANGED" | grep -q '^server/'; then
            echo "server_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "server_changed=false" >> "$GITHUB_OUTPUT"
          fi

  client-checks:
    needs: detect-changes
    if: needs.detect-changes.outputs.client_changed == 'true'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: client
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: client/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Check formatting (Prettier)
        run: npm run format:check

      - name: Lint (Oxlint)
        run: npm run lint

      - name: TypeScript + build
        run: npm run build

  server-checks:
    needs: detect-changes
    if: needs.detect-changes.outputs.server_changed == 'true'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: server
    steps:
      - uses: actions/checkout@v4

      - uses: erlef/setup-beam@v1
        with:
          elixir-version: '1.18.1'
          otp-version: '27.2'

      - name: Cache Mix deps
        uses: actions/cache@v4
        with:
          path: |
            server/deps
            server/_build
          key: ${{ runner.os }}-mix-${{ hashFiles('server/mix.lock') }}
          restore-keys: ${{ runner.os }}-mix-

      - name: Install dependencies
        run: mix deps.get

      - name: Check formatting (mix format)
        run: mix format --check-formatted

      - name: Lint (Credo)
        run: mix credo --strict

      - name: Run tests
        run: mix test
```

**Step 2: Verify the YAML is valid**

```bash
cat .github/workflows/ci.yml | python3 -c "import sys, yaml; yaml.safe_load(sys.stdin); print('YAML valid')"
```

Expected: `YAML valid`

**Step 3: Commit**

```bash
git add .github/workflows/ci.yml
git commit -m "feat: add manual PR guard CI workflow (lint, format, test)"
```

---

## Task 8: Create the Release workflow

**Files:**
- Create: `.github/workflows/release.yml`

**Context:** Triggers on tag push matching `v*`. Builds the Docker image and pushes it to
GitHub Container Registry (ghcr.io). Uses the built-in `GITHUB_TOKEN` — no extra secrets
needed. Images are tagged with the semver from the git tag (e.g. `v1.2.3` → `1.2.3` and `1.2`).

**Step 1: Create `.github/workflows/release.yml`**

```yaml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
```

**Step 2: Verify the YAML is valid**

```bash
cat .github/workflows/release.yml | python3 -c "import sys, yaml; yaml.safe_load(sys.stdin); print('YAML valid')"
```

Expected: `YAML valid`

**Step 3: Commit**

```bash
git add .github/workflows/release.yml
git commit -m "feat: add release workflow to build and push Docker image to GHCR on tag"
```

---

## Task 9: Post-merge GitHub configuration (manual steps)

These steps are done in the GitHub web UI after all code is merged to main.

**Set up branch protection for main:**

1. Go to repo → Settings → Branches → Add rule (or edit existing)
2. Branch name pattern: `main`
3. Enable: "Require status checks to pass before merging"
4. Search for and add required status checks:
   - `client-checks`
   - `server-checks`
5. Enable: "Require branches to be up to date before merging"
6. Save

**How to trigger a release:**

```bash
git tag v1.0.0
git push origin v1.0.0
```

The release workflow triggers automatically, builds the image, and pushes to
`ghcr.io/<org>/tetris:1.0.0` and `ghcr.io/<org>/tetris:1.0`.
